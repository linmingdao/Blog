# vue 源码分析前置知识

### 会使用到的 API

[Object.defineProperty(), setter, getter](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)

[Node.nodeType](https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeType): 值为 `1` 表示是元素节点

[Element.querySelector()](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/querySelector): 返回与指定的选择器组匹配的元素的后代的`第一个`元素

[Document.createDocumentFragment()](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/createDocumentFragment): 内存中操作 DOM, 避免浏览器多次渲染

[Function.prototype.bind()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind): 改变方法 `this` 指向

类数组 转 数组

[RegExp.$1-$9](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/n)

### 单向数据绑定: Model -> View

如何监听 Model 改变了: Object.defineProperty 递归劫持各个属性的 setter，getter

Model 改变了如何触发对应视图的改变, Model 和 视图 的映射: 模板编译器 Compiler

### 双向数据绑定, 在单向的基础上, View(表单组件) -> Model

监听表单组件的变更事件, 改变 Model 上的对应数据

## Vue MVVM 部分源码解析

[源码分析的 Demo 地址](https://github.com/linmingdao/mvvm)

### 构造器干了什么: new Vue()

- 数据代理
- 利用 Object.defineProperty 将 options.data 都代理到 vm 上, 这样可以在 methods 里面直接通过 this.xxx 来访问或者设置 Model
- 在构造器里通过 observe(data) 递归劫持 Model 的 setter 与 getter

### Observer 干了什么

- Object.defineProperty, setter 里面监测 Model 变更, 触发视图更新, Object.defineProperty getter 里面收集依赖
- 确保 Model 上的每个层级都被劫持
- 在 Object.defineProperty 里面 初始化 Dep

### Dep(订阅发布)

- 添加 watcher 实例到订阅者列表
- notify(通知) 订阅者(watcher) update

### 模板编译器 Compiler 干了什么

- 利用 Document.createDocumentFragment Api 在内存中将 Vue 的模板编译成普通的 html
- 原生不支持的标签会被保留下来, 只是不会在界面中显示而已, 所以编译器可以通过元素的子元素信息获取模板中 Vue 组件标签
- 递归编译所有节点, 把所有跟 Vue 相关的内容转换成标准 html
- 初始化 Wathcer

### Watcher 干了什么

- addDep

### nextTick

批量地推入多次 model 变更

如何检测 dom 更新完毕

进而调用 nextTick 回调
