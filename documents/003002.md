# 微任务, 宏任务 与 Event-Loop

## 零. 请永远保持好奇, 并消除好奇

推荐阅读:

[MDN EventLoop](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop)

[这一次，彻底弄懂 JavaScript 执行机制](https://juejin.im/post/6844903512845860872)

[HTML Standard ](https://html.spec.whatwg.org/multipage/webappapis.html)

## 一. JS 运行机制

单线程, 函数执行栈, 同步任务, 异步任务, 消息队列(事件循环机制 Event Loop)

> 主线程执行栈为空呢 ? js 引擎存在 monitoring process 进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去 Event Queue 那里检查是否有等待被调用的函数。

<p align="center"><img src=https://linmingdao.github.io/blog/assets/tech/003002_00.jpg></p>

```js
console.log("script start");

setTimeout(function () {
  console.log("setTimeout");
}, 0);

Promise.resolve()
  .then(function () {
    console.log("promise1");
  })
  .then(function () {
    console.log("promise2");
  });

console.log("script end");

// script start, script end, promise1, promise2, setTimeout
```

```js
console.log("1");

setTimeout(() => {
  console.log("2");
}, 0);

console.log("3");

new Promise((resolve, reject) => {
  resolve(1);
  console.log("4");
})
  .then((res) => {
    console.log("5");
  })
  .then((res) => {
    console.log("6");
  });

console.log("7");

// 1，3，4，7, 5, 6，2
```

## 二. 你不知道的 setTimeout

## 三. 你不知道的 setInterval

## 四. Promise 与 process.nextTick(callback), 宏任务 与 微任务

除了广义的同步任务和异步任务, 我们对任务有更精细的定义:

> macro-task(宏任务): 包括整体代码 script, setTimeout, setInterval

> micro-task(微任务): Promise, process.nextTick

不同类型的任务会进入对应的 Event Queue, 比如 setTimeout 和 setInterval 会进入 宏任务 Event Queue, Promise 和 process.nextTick 会进入 微任务 Event Queue

事件循环的顺序，决定 js 代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务

<p align="center"><img src=https://linmingdao.github.io/blog/assets/tech/003002_01.jpg></p>

```js
setTimeout(function () {
  console.log("setTimeout");
});

new Promise(function (resolve) {
  console.log("promise");
}).then(function () {
  console.log("then");
});

console.log("console");

// promise, console, then, setTimeout
```

- 这段代码作为宏任务，进入主线程。
- 先遇到 setTimeout，那么将其回调函数注册后分发到 宏任务 Event Queue。(注册过程与上同，下文不再描述)
- 接下来遇到了 Promise，new Promise 立即执行，then 函数分发到 微任务 Event Queue。
- 遇到 console.log()，立即执行。
- 好啦，整体代码 script 作为第一个宏任务执行结束，看看有哪些微任务？我们发现了 then 在微任务 Event Queue 里面，执行。
- ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务 Event Queue 开始。我们发现了宏任务 Event Queue 中 setTimeout 对应的回调函数，立即执行。
- 结束。

## 五. 常见的 宏任务 和 微任务

<p align="center"><img src=https://linmingdao.github.io/blog/assets/tech/003002_02.jpg></p>

## 六. 如何优雅地插入 10W 行 DOM

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>十万条数据</title>
  </head>
  <body>
    <input type="text" />
    <ul></ul>
    <script>
      setTimeout(() => {
        // 插入十万条数据
        const total = 100000;
        // 一次插入 20 条，如果觉得性能不好就减少
        const once = 20;
        // 渲染数据总共需要几次
        const loopCount = total / once;
        let countOfRender = 0;
        let ul = document.querySelector("ul");
        function add() {
          // 优化性能，插入不会造成回流
          const fragment = document.createDocumentFragment();
          for (let i = 0; i < once; i++) {
            const li = document.createElement("li");
            li.innerText = Math.floor(Math.random() * total);
            fragment.appendChild(li);
          }
          ul.appendChild(fragment);
          countOfRender += 1;
          loop();
        }
        function loop() {
          if (countOfRender < loopCount) {
            window.requestAnimationFrame(add);
          }
        }
        loop();
      }, 0);
    </script>
  </body>
</html>
```

### 探究 nextTick 原理

批量地推入多次 model 变更

如何检测 dom 更新完毕

进而调用 nextTick 回调
